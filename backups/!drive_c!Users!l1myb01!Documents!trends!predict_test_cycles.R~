## Table 3: predictive regressions
rm(list = ls())
require(sandwich) # NeweyWest()
require(xtable) # xtable()
source("R/trends_fns.R")

## restricted vs. unrestricted regressions -- levels vs cycles
df <- loadData()
h <- 4
## yields and PCs
Y <- data.matrix(df[,attr(df, "yield.cols")])
W <- eigen(cov(Y))$vectors[,1:3]
W <- W %*% diag(sign(W[nrow(W),])) # make sure PC1 and PC2 correspond to level and slope
scale <- c(sum(W[,1]), W[nrow(W),2]-W[1,2], W[nrow(W),3]-2*W[mats==2,3]+W[1,3])
## but then the loadings are not orthonormal, so we just scale the coefficients and SEs
df[paste0("PC", 1:3)] <- Y %*% W
df[paste0("PC", 1:3, "sc")] <- Y %*% W %*% diag(1/scale)
## scaled PCs on similar scale with level/slope/curve but loadings not orthonormal (don't use in bootstrap)
attr(df, 'mats') <- mats
attr(df, 'W') <- W
T <- nrow(Y)
df$xr.avg <- 0
for (n in 2:15) {
    nmh <- ifelse(h==1, n, n-1) # approximate n-h - yield if quarterly change
    xrn <- c(-(n-h/4)*Y[(1+h):T, mats==nmh] + n*Y[1:(T-h), mats==n] - h/4*Y[1:(T-h), mats==h/4], rep(NA, h))
    df$xr.avg <- df$xr.avg + xrn/14
}

fmla_ur <- xr.avg ~ PC1sc + PC2sc + PC3sc + istar
mod <- lm(fmla_ur, df)
cat("R^2 =", summary(mod)$r.squared, "\n")
