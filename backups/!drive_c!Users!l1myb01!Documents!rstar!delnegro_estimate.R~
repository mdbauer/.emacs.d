## replicate Del Negro et al's benchmark model estimates
## v2: use KFAS for simulation smoother, don't draw initial values

rm(list=ls())
library(Matrix) # for bdiag(), Matrix()
library(KFAS)   ## SSModel(), simulateSSM()
library(MCMCpack) # for riwish()
## library(ggplot2)  # for debugging plots
## library(microbenchmark)
## library(profvis)

drawStates <- function(Y, pars, prior) {
    ## Globals: n, p, q, Y, Adiag
    ## measurement equation
    Lambda <- matrix(0, n, q)
    Lambda[3:5,1] <- 1; Lambda[,2] <- 1; Lambda[4,3] <- 1
    Z <- cbind(Lambda, diag(n), matrix(0, n, n*(p-1)))
    ## transition equation
    F <- rbind(t(pars$Phi), cbind(diag(n*(p-1)), matrix(0, n*(p-1), n)))
    Tmat <- as.matrix(bdiag(diag(q), F))
    R <- rbind(diag(q+n), matrix(0, n*(p-1), q+n))
    Q <- as.matrix(bdiag(pars$Sigma_e, pars$Sigma_eps))
    ## initial conditions
    a0 <- c(prior$ybar0, numeric(n*p))
    Q_Hamilton <- as.matrix(bdiag(pars$Sigma_eps, matrix(0, n*(p-1), n*(p-1))))
    ## solve Lyapunov equation for unconditional variance
    A <- Adiag - kronecker(F, F)
    Asp <- as(A, "sparseMatrix") # circumvents the tests in Matrix(A)
    vecV <- solve(Asp,  as.numeric(Q_Hamilton))
    V <- matrix(vecV, n*p, n*p)
    P0 <- as.matrix(bdiag(prior$Vbar0, V))

    mod <- SSModel(Y ~ -1 + SSMcustom(Z=Z, T=Tmat, R=R, Q=Q, a1=a0, P1=P0), H=matrix(0, n, n))
    sim <- simulateSSM(mod, type="states")
    t(sim[,,1])
}

##########################################################
### begin main script

## settings
n <- 5 ## number of observed variables in VAR -- each has stationary component
q <- 3 ## number of trends
p <- 5 ## lags in VAR
Adiag <- diag((n*p)^2)
M <- 50000 ## 50000 ## number of MCMC draws -- discard the first half

## load data
df <- read.csv("data/delnegro.csv", na.string="#N/A")
df$date <- as.Date(df$date, format="%m/%d/%Y")
quarter <- as.numeric(format(df$date, "%m")) %/% 3 + 1
df$yyyyq <- as.numeric(format(df$date, "%Y"))*10 + quarter
df <- subset(df, yyyyq >= 19601 & yyyyq <= 20164)
df$pi_e[df$yyyyq <= 19701] <- NA
df$y1[df$yyyyq >= 20084] <- NA
Y <- as.matrix(df[c("pi", "pi_e", "y1", "y80", "y1_e")])
T <- nrow(df)

## priors
Psi <- c(2, .5, 1, 1, .5)
lambda <- .05 # .2  extra tight
prior <- list(Sigma_e = diag(c(1/400, 1/200, 1/400)),
              kappa_e = 100,
              Sigma_eps = diag(Psi),
              kappa_eps = n+2,
              Omega = diag(rep((lambda/(1:p))^2, each=n)/rep(Psi, p)), # assumes kappa_eps = n+2
              ybar0 = c(0.5, 2, 1),
              Vbar0 = diag(q),
              Phi = matrix(0, n*p, n))
prior$Omega_inv <- solve(prior$Omega)
#prior$Omega_inv <- matrix(0, n*p, n*p)  # alternative to Minnessota prior: disperse prior for Phi

## MCMC
phi <- matrix(NA, M, n^2*p)
sigma_e <- matrix(NA, M, q*(q+1)/2)
sigma_eps <- matrix(NA, M, n*(n+1)/2)
X <- array(NA, c(M, n+q, T))

pars <- prior[c("Sigma_e", "Sigma_eps", "Phi")] # initialize parameters at prior modes

## Rprof()
## profwidget <- profvis({

start <- Sys.time()
reject <- logical(M)
for (j in 1:M) {
    if (j %% 1000 == 0)
        cat("iteration", j, "\n")

    ## draw states
    pars$X <- drawStates(Y, pars, prior)  ## (q+n*p) x T

    ## draw Sigma_e
    delta <- pars$X[1:q, -1] - pars$X[1:q, -T]
    Se <- delta %*% t(delta)
    pars$Sigma_e <- riwish(prior$kappa_e + T-1, prior$Sigma_e*(prior$kappa_e+q+1) + Se)

    ## conditional posterior mean for VAR parameters
    ydat <- t(pars$X[seq(q+1, q+n), seq(2, T)])  # T-1 x n
    xdat <- t(pars$X[seq(q+1, q+n*p), seq(1, T-1)])# T-1 x np
    Mstar <- solve(t(xdat) %*% xdat + prior$Omega_inv)
    Phi_post <- Mstar %*% (t(xdat) %*% ydat + prior$Omega_inv %*% prior$Phi) # np x n

    ## draw Sigma_eps
    resids <- ydat - xdat %*% Phi_post   # T-1 x n
    Seps <- t(resids) %*% resids + t(Phi_post - prior$Phi) %*% prior$Omega_inv %*% (Phi_post - prior$Phi)
    pars$Sigma_eps <- riwish(prior$kappa_eps + T-1, prior$Sigma_eps*(prior$kappa_eps+n+1) + Seps)

    ## draw Phi
    phi_draw <- as.numeric(Phi_post) + t(chol(kronecker(pars$Sigma_eps, Mstar))) %*% rnorm(n^2*p)
    Phi_prop <- matrix(phi_draw, n*p, n)
    F <- rbind(t(Phi_prop), cbind(diag(n*(p-1)), matrix(0, n*(p-1), n)))
    if (max(abs(eigen(F)$values))<1) {
        pars$Phi <- Phi_prop
    } else {
        reject[j] <- TRUE
    }

    ## save draws
    phi[j,] <- as.numeric(pars$Phi)
    sigma_e[j,] <- as.numeric(pars$Sigma_e[lower.tri(diag(q), TRUE)])
    sigma_eps[j,] <- as.numeric(pars$Sigma_eps[lower.tri(diag(n), TRUE)])
    X[j,,] <- pars$X[seq(n+q),]
}
## Rprof(NULL)
## print(summaryRprof())
cat(M, "iterations take\n")
print(Sys.time()-start)

## })
## print(profwidget)

## ## remove burn-in sample
## ind <- seq(M/2+1, M)
## X <- X[ind,,]
## phi <- phi[ind,]
## sigma_e <- sigma_e[ind,]
## sigma_eps <- sigma_eps[ind,]

## save estimation results
description <- "v2 - with very tight prior on Phi, 9/7/2017"
save(df, n, q, p, prior, phi, reject, sigma_e, sigma_eps, Y, X, description, file=paste0("results/delnegro_", Sys.Date(), ".RData"))
