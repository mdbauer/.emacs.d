loadLW <- function() {
    ## Laubach-Williams
    lw <- read.csv("data/LaubachWilliams.csv" , na.strings = "#N/A")
    lw$yyyymm <- lw$Year*100+lw$Quarter*3
    lw <- lw[c("yyyymm", "Rstar_LW_filtered", "Rstar_LW_smoothed")]
    names(lw)[2:3] <- c("rstar.lw", "rstar.lw.sm")
    lw
}

loadJM <- function() {
    ## Johannsen-Mertens
    jm <- read.csv("data/JohannsenMertensFiltered.csv", stringsAsFactors = FALSE)
    colnames(jm) <- c('date', 'rstar.jm')
    jm$year <- floor(jm$date/100)
    jm$quarter <- jm$date-jm$year*100
    jm$yyyymm <- jm$year*100 + jm$quarter*3
    jm[c("yyyymm", "rstar.jm")]
}

loadLM <- function() {
    ## Lubik-Mathes
    lm <- read.csv("data/LubikMathes.csv")
    lm$year <- floor(lm$date)
    lm$quarter <- (lm$date - lm$year)*4 + 1
    lm$yyyymm <- lm$year*100 + lm$quarter*3
    lm <- lm[c("yyyymm", "median")]
    names(lm)[2] <- "rstar.lm"
    lm
}

loadKiley <- function() {
    ## Kiley
    kiley <- read.table("data/Kiley.csv", header=TRUE)
    names(kiley) <- c("date", "X", "rstar.kiley")
    kiley$year <- floor(kiley$date)
    kiley$quarter <- (kiley$date - kiley$year)*4 + 1
    kiley$yyyymm <- kiley$year*100 + kiley$quarter*3
    kiley <- kiley[c("yyyymm", "rstar.kiley")]
    kiley
}

loadData <- function() {
    ## yields
    df <- read.csv("data/yields_gsw_monthly.csv")
    yield.cols <- names(df)[-1]
    df$yyyymm <- floor(df$Date/100)
    df$year <- floor(df$yyyymm/100)
    df$month <- df$yyyymm-df$year*100
    df$date <- as.Date(as.character(df$Date), format="%Y%m%d")
    df$Date <- NULL

    ## ex ante real rate using SPF
    spf <- read.csv("data/spf_inflation.csv", na.string="#N/A")
    spf$yyyymm <- spf$YEAR*100 + spf$QUARTER*3
    spf$pi.spf <- spf$INFPGDP1YR
    ind <- which(spf$yyyymm == 197409)
    spf$pi.spf[ind] <- spf$pi.spf[ind-1]
    spf <- spf[c("yyyymm", "pi.spf")]
    df <- merge(df, spf, all.x = TRUE)
    df$earr <- df$y1 - df$pi.spf

    df <- merge(df, loadLW(), all.x = TRUE)
    df <- merge(df, loadLM(), all.x = TRUE)
    df <- merge(df, loadJM(), all.x = TRUE)

    ## PTR
    ptr <- read.csv("data/pistar_PTR.csv")
    ptr$yyyymm <- ptr$Year*100+(ptr$Quarter)*3
    ptr <- ptr[c("yyyymm", "pistar_PTR")]
    names(ptr)[2] <- "ptr"
    df <- merge(df, ptr, all.x = TRUE)

    ## Core CPI
    cpi <- read.csv("data/CPIcore.csv")
    names(cpi) <- c("Date", "corecpi")
    cpi$date <- as.Date(cpi$Date, format="%m/%d/%Y")
    cpi$yyyymm <- as.numeric(format(cpi$date, "%Y%m"))
    cpi$pi <- 100*c(rep(NA, 12), diff(log(cpi$corecpi), 12)) # y-o-y core CPI inflation
    cpi <- cpi[c("yyyymm", "pi")]
    df <- merge(df, cpi, all.x = TRUE)

    df <- df[df$month %% 3 == 0, ] # make quarterly
    rownames(df) <- NULL
    df[setdiff(yield.cols, "y1")] <- NULL

    df
}

getEWMA <- function(x, v = 0.987, y0) {
    ## calculate exponentially-weighted moving average as in Cieslak-Povala
    tau <- numeric(length(x))
    if (missing(y0)) {
        tau[1] <- x[1]
    } else {
        tau[1] <- y0
    }
    for (t in 2:length(x))
	tau[t] <- tau[t-1] + (1-v)*(x[t] - tau[t-1])
    tau
}

getMA <- function(x, k)
    tail(cumsum(x) - cumsum(c(rep(0, k), head(x, -k))), -k + 1)/k

fkf.R <- function(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt, smooth=FALSE) {
    T <- ncol(yt)
    N <- nrow(dt) # number of states
    d <- nrow(ct) # number of measurements

    ## state/transition equation: x_t = d_t + T_t * x_t-1 + innov, cov = HHt
    ## measurement equation:      y_t = c_t + Z_t * x_t   + innov, cov = GGt
    ## note: parameters (ct, dt, Zt, Tt, HHt, GGt) assumed to be CONSTANT -- using first element
    att <- matrix(NA, N, T)        # E_t x_t
    at <- matrix(NA, N, T+1)       # E_t-1 x_t
    Ptt <- array(NA, c(N, N, T))   # Var_t x_t
    Pt <- array(NA, c(N, N, T+1))  # Var_t-1 x_t
    vt <- matrix(NA, d, T)         # y_t - E_t-1 x_t
    Ft <- array(NA, c(d, d, T))
    Kt <- array(NA, c(N, d, T))
    logLik = - d*T*log(sqrt(2*pi))
    at[,1] = a0
    Pt[,,1] = P0

    Z <- matrix(Zt[,,1], dim(Zt)[1], dim(Zt)[2])

    for (i in 1:T) {
        vt[, i] = yt[, i] - ct[, 1] - Z %*% at[, i]
        Ft[,, i] = Z %*% Pt[,, i] %*% t(Z) + GGt[,, 1]
        if (d==1) {
            logLik <- logLik - 0.5 * (log(Ft[,,i]) + vt[,i]^2 / Ft[,,i])
            Kt[,, i] = Pt[,, i] %*% t(Z) / Ft[,,i]
            att[, i] = at[, i] + Kt[,, i] * vt[, i]
        } else {
            ## Ft.inv <- tryCatch(solve(Ft[,, i]),
            ##                    error = {
            ##                        print("couldn't invert matrix")
            ##                        browser()
            ##                    })
            ## if (det(Ft[,,i])<1e-15)
            ##     print("pretty close to singular!")
            Ft.inv <- solve(Ft[,, i])
            if (any(is.na(Ft[,,i]))) {
                stop("missing value in prediction error variance\n")
                browser()
            }
            if (det(Ft[,,i])<0) {
                stop("determinant of prediction error variance is negative\n")
                browser()
            }
            logLik <- logLik - 0.5 * (log(det(Ft[,,i])) + t(vt[,i]) %*% Ft.inv %*% vt[,i])
            Kt[,, i] = Pt[,, i] %*% t(Z) %*% Ft.inv
            att[, i] = at[, i] + Kt[,, i] %*% vt[, i]
        }
        Ptt[,, i] = Pt[,, i] - Pt[,, i] %*% t(Z) %*% t(Kt[,, i])
        at[, i + 1] = dt[, 1] + Tt[,, 1] %*% att[, i]
        Pt[,, i + 1] = Tt[,, 1] %*% Ptt[,, i] %*% t(Tt[,, 1]) + HHt[,, 1]
    }
    rval <- list(att=att, at=at, Ptt=Ptt, Pt=Pt, vt=vt, Ft=Ft, Kt=Kt, logLik = logLik)
    if (smooth) {
        ## based on Shumway and Stoffer
        atT <- matrix(NA, N, T)
        PtT <- array(NA, c(N, N, T))
        Jt <- array(NA, c(N, N, T))
        atT[, T] <- att[, T]
        PtT[,, T] <- Ptt[,, T]
        for (t in (T-1):1) {
            Jt[,, t] <- Ptt[,, t] %*% t(Tt[,, 1]) %*% solve(Pt[,,t+1])
            atT[, t] <- att[, t] + Jt[,, t] %*% (atT[, t+1] - at[, t+1])
            PtT[,, t] <- Ptt[,, t] + Jt[,, t] %*% (PtT[,, t+1] - Pt[,, t+1]) %*% t(Jt[,, t])
        }
        CtT <- array(NA, c(N, N, T)) # CtT[,,t] = Cov(x(t), x(t-1)|data)
        CtT[,, T] <- (diag(N) - Kt[,, T] %*% Z) %*% Tt[,, 1] %*% Ptt[,, T-1]
        for (t in (T-1):2)
            CtT[,, t] <- Ptt[,,t] %*% t(Jt[,,t-1]) + Jt[,,t] %*% (CtT[,, t+1] - Tt[,, 1]%*%Ptt[,, t]) %*% t(Jt[,, t-1])
        rval$atT <- atT
        rval$PtT <- PtT
        rval$CtT <- CtT
    }
    rval
}

checkKKT <- function(theta, obj) {
    ## check result of numerical optimization
    require(numDeriv)
    y <- obj(theta)
    kkttol <- 10*.Machine$double.eps^(1/4)
    kkt2tol <- 100* (.Machine$double.eps^(1/4))
    ngatend <- grad(obj, theta)
    cat("Gradient:")
    print(ngatend)
    kkt1 <- max(abs(ngatend)) <= kkttol*(1.0+abs(y))
    cat("kkt1 = ", kkt1, "\n")
    nhatend <- hessian(obj, theta)
    hev <- eigen(nhatend)$values
    cat("Eigenvalues:", hev, "\n")
    negeig <- (hev <= -kkttol*(1+abs(y)))
    cat("negeig = ", negeig, "\n")
    evratio <- tail(hev, 1)/hev[1]
    cat("evratio =", evratio, "\n")
    cat("evratio requirement >", kkt2tol,"\n")
    kkt2 <- (evratio > kkt2tol) && (!negeig)
    cat("kkt2 =", kkt2, "\n")
}
