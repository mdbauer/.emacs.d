## replicate Del Negro et al's benchmark model estimates

rm(list=ls())
graphics.off()
## options(error = recover)
## source("R/uc_fns.R")  # est.uc, kalman.uc
## source("R/fns.R")
require(MCMCpack)

## load data
df <- read.csv("data/delnegro.csv", na.string="#N/A")
df$date <- as.Date(df$date, format="%m/%d/%Y")
quarter <- as.numeric(format(df$date, "%m")) %/% 3 + 1
df$yyyyq <- as.numeric(format(df$date, "%Y"))*10 + quarter
df <- subset(df, yyyyq >= 19601 & yyyyq <= 20164)
df$y1[df$yyyyq >= 20084] <- NA
Y <- t(as.matrix(df[c("pi", "pi_e", "y1", "y80", "y1_e")]))

n <- 5 ## number of observed variables in VAR -- each has stationary component
q <- 3 ## number of trends
p <- 5 ## lags in VAR
M <- 10000 ## number of MCMC draws -- discard the first half
T <- nrow(df)

## priors
Psi <- c(2, .5, 1, 1, .5)
lambda <- .2
prior <- list(Sigma_e = diag(c(1/400, 1/200, 1/400)),
              kappa_e = 100,
              Sigma_eps = diag(Psi),
              kappa_eps = n+2,
              Omega = diag(rep((lambda/(1:p))^2, each=n)/rep(Psi, p)), # assumes kappa_eps = n+2
              ybar0 = c(0.5, 2, 1),
              Vbar0 = diag(q),
              Phi = matrix(0, n, p*n))

## MCMC
phi <- matrix(NA, M, n^2*p)
sigma_e <- matrix(NA, M, q*(q+1)/2)
sigma_eps <- matrix(NA, M, n*(n+1)/2)
X <- array(NA, c(M, n+q, T+1))

pars <- prior[c("Sigma_e", "Sigma_eps", "Phi")] # initialize parameters at prior modes
## pars$Phi[1:5, 1:5] <- 0.9*diag(5)

drawNormal <- function(mu, Omega)
    mu + t(chol(Omega)) %*% rnorm(length(mu))

kalman <- function(Tmat, R, Q, Z, H, a0, P0, Y) {
    T <- ncol(Y)
    N <- nrow(Tmat) # states
    d <- nrow(Z)    # observations

    at <- matrix(NA, N, T+1)       # E_t-1 x_t
    Pt <- array(NA, c(N, N, T+1))  # Var_t-1 x_t
    Lt <- array(NA, c(N, N, T))
    tmp <- matrix(NA, N, T)
    at[,1] = a0
    Pt[,,1] = P0
    for (t in 1:T) {
        ind <- !is.na(Y[, t])
        Z2 <- Z[ind,]
        vt <- Y[ind, t] - Z2 %*% at[, t]
        Ft <- Z2 %*% Pt[,, t] %*% t(Z2) + H[ind, ind]
        FtInv <- solve(Ft)
        Kt <- Tmat %*% Pt[,, t] %*% t(Z2) %*% FtInv
        Lt[,,t] <- Tmat - Kt %*% Z2
        tmp[,t] <- t(Z2) %*% FtInv %*% vt
        at[, t + 1] <- Tmat %*% at[, t] + Kt %*% vt
        Pt[,, t + 1] <- Tmat %*% Pt[,, t] %*% t(Lt[,,t]) + R %*% Q %*% t(R)
    }

    ## state smoothing
    rt <- matrix(NA, N, T+1)  # r[t] = r_{t-1}
    rt[,T+1] <- numeric(N)  # r_T
    for (t in T:1)
        rt[,t] <- tmp[,t] + t(Lt[,,t])%*%rt[,t+1] # (4.38)
    atT <- matrix(NA, N, T+1)
    atT[, 1] <- at[,1] + Pt[,,1]%*%rt[,1] # * r_0
    for (t in 1:T)
        atT[, t+1] <- Tmat %*% atT[, t] + R %*% Q %*% t(R) %*% rt[,t]
    rval <- list(at=at, Pt=Pt, atT = atT[,1:T])
}

drawStates <- function(Y, pars, prior) {
    ## Globals: n, p, q
    require(Matrix) # for bdiag
    ## measurement equation
    Lambda <- matrix(0, n, q)
    Lambda[3:5,1] <- 1; Lambda[,2] <- 1; Lambda[4,3] <- 1
    Z <- cbind(Lambda, diag(n), matrix(0, n, n*(p-1)))
    ## transition equation
    F <- rbind(pars$Phi, cbind(diag(n*(p-1)), matrix(0, n*(p-1), n)))
    Tmat <- as.matrix(bdiag(diag(q), F))
    R <- rbind(diag(q+n), matrix(0, n*(p-1), q+n))
    Q <- as.matrix(bdiag(pars$Sigma_e, pars$Sigma_eps))
    ## initial conditions
    a0 <- c(prior$ybar0, numeric(n*p))
    Q_Hamilton <- as.matrix(bdiag(pars$Sigma_eps, matrix(0, n*(p-1), n*(p-1))))
    V <- matrix(solve(diag((n*p)^2) - kronecker(F, F)) %*% as.numeric(Q_Hamilton), n*p, n*p)
    P0 <- as.matrix(bdiag(prior$Vbar0, V))

    ## ## Kalman filter
    ## require(FKF)
    ## rval <- fkf(a0, P0, dt = matrix(0, q+n*p, 1), ct = matrix(0, n, 1),
    ##             Tt = array(Tmat, c(q+n*p, q+n*p, 1)), Zt = array(Z, c(n, q+n*p, 1)),
    ##             HHt = array(R %*% Q, c(q+n*p, q+n*p, 1)), GGt = array(0, c(n, n, 1)),
    ##             yt = Y)
    ## print(rval$at[,1:5])

    ## use KFAS
    require(KFAS)
    yt <- t(Y)
    mod <- SSModel(yt ~ -1 + SSMcustom(Z, Tmat, R, Q, a0, P0), H=matrix(0, n, n))
    out <- KFS(mod)
    ## print(t(out$a[1:5,]))
    print(t(out$alphahat[1:5,]))

    ## my Kalman filter
    rval <- kalman(Tmat, R, Q, Z, H=matrix(0, n, n), a0, P0, Y)
    ## print(rval$at[,1:5])
    print(rval$atT[,1:5])
    stop()

    ## simulation smoother
    T <- ncol(Y)
    ## (1) draw states and data from unconditional distribution
    e <- t(chol(pars$Sigma_e)) %*% matrix(rnorm(T*q), q, T)
    eps <- t(chol(pars$Sigma_eps)) %*% matrix(rnorm(T*n), n, T)
    alpha_plus <- matrix(NA, q+n*p, T)
    alpha_plus[1:q, 1] <- rnorm(q, mean=prior$ybar0, sd=sqrt(diag(prior$Vbar0)))
    alpha_plus[-(1:q), 1] <- t(chol(V)) %*% rnorm(n*p)
    for (t in 2:T)
        alpha_plus[, t] <- Tmat %*% alpha_plus[, t-1] + R %*% c(e[,t], eps[,t])
    Y_plus <- Z %*% alpha_plus
    rval_plus <- kalman(Tmat, R, Q, Z, H=matrix(0, n, n), a0, P0, Y_plus)
    alpha_draw <- alpha_plus - rval_plus$atT + rval$atT
    stop()

    ## simulate states 1000 times using my approach and KFS, compare histograms
    ## figure out initial values
}

for (j in 1:M) {
    if (j %% 1000 == 0)
        cat("iteration", j, "\n")

    ## draw states
    pars$X <- drawStates(Y, pars, prior)

    ## draw Sigma_e

    ## draw Sigma_eps

    ## draw Phi

    ## save draws
    phi[j,] <- as.numeric(pars$Phi)
    sigma_e[j,] <- as.numeric(pars$Sigma_e[lower.tri(diag(q), TRUE)])
    sigma_eps[j,] <- as.numeric(pars$Sigma_eps[lower.tri(diag(q), TRUE)])
    X[j,,] <- pars$X
}




