## some alternative specifications with i*
## findings:
## - using PCs of detrended yields helps a lot
## - though doesn't work quite as well as leaving it unrestricted
## - maybe more ROBUST to use detrended yields instead of unrestricted

rm(list=ls())
require(xtable) # xtable()
source("R/trends_fns.r")
source("R/bootstrap_fns.r")

makePCs <- function(Y, detrend = c(0,1,2), N=3) {
    if (detrend == 1) {
        Y <- Y - df$pistar.ptr
    } else if (detrend == 2) {
        Y <- Y - df$pistar.ptr - df$rstar.mean
    }
    W <- eigen(cov(Y))$vectors[,1:N]
    Y %*% W
}

addAllPCs <- function(df, Y) {
    if (missing(Y))
        Y <- data.matrix(df[yield.cols])
    df[paste0("PC", 1:3)] <- makePCs(Y, detrend = 0)
    df[paste0("PC", 1:3, "cpo")] <- makePCs(Y, detrend = 1)
    df[paste0("PC", 1:3, "d")] <- makePCs(Y, detrend = 2)
    df
}

getR2 <- function(df) {
    mod1 <- lm(xr.avg ~ PC1 + PC2 + PC3, df)
    mod2 <- lm(xr.avg ~ PC1cpo + PC2cpo + PC3cpo, df)
    mod3 <- lm(xr.avg ~ PC1d + PC2d + PC3d, df)
    rval <- sapply(list(mod1, mod2, mod3), function(mod) summary(mod)$r.squared)
    round(rval, 3)
}

h <- 4  # holding period
to.latex <- FALSE

tbl <- data.frame(matrix(NA, 6, 5))
tbl[,1] <- sprintf("%-15s", c("Actual yields", "",
                              "Detrended with \\pi^\\ast_t", "",
                              "Detrended with \\pi^\\ast_t and r^\\ast", ""))
col <- 2
for (subsample in c(FALSE, TRUE)) {
    df <- loadData()
    if (subsample)
        df <- df[df$yyyymm >= 198501, ]
    cat("Date range:", range(df$yyyymm), "\n")
    yield.cols <- attr(df, "yield.cols")
    Y <- data.matrix(df[yield.cols])
    attr(df, "W") <- eigen(cov(Y))$vectors[,1:3] # needed for bootstrap
    mats <- c(0.25, 0.5, 1:15)
    attr(df, "mats") <- mats

    ## calculate excess returns
    T <- nrow(df)
    for (n in 2:15) {
        nm <- paste0("xr", n)
        df[nm] <- c(-(n-h/4)*Y[(1+h):T, mats==ifelse(h==1, n, n-1)] + n*Y[1:(T-h), mats==n] - h/4*Y[1:(T-h), mats==h/4], rep(NA, h))
    }
    df$xr.avg <- rowMeans(as.matrix(df[paste0("xr", 2:15)]))

    ## PCs of yields
    df <- addAllPCs(df, Y)

    ## data
    tbl[c(1,3,5),col] <- getR2(df)
    print(tbl)

    ## bootstrapping
    varnames <- c("pistar.ptr", "rstar.mean")
    dgp <- getBootDGP(c("PC1", "PC2", "PC3"), varnames, df, BC=TRUE)
    M <- 5000
    cat("# Simulating bootstrap samples: T =", T, ", M =", M, "...\n")
    R2 <- matrix(NA, M, 3)
    for (b in 1:M) {
        simData <- simulateData(dgp, T, h)
        if (h==4) {
            simData$xr.avg <- simData$xr.a
        } else {
            simData$xr.avg <- simData$xr.q
        }
        simData <- addAllPCs(simData)
        R2[b,] <- getR2(simData)
    }
    tbl[c(2,4,6), col+(0:1)] <- t(apply(R2, 2, quantile, c(.025, .975)))
    print(tbl)
    col <- col+2
}
print(tbl)

ind <- cbind(c(2,4,6), c(2,2,2,4,4,4))
tbl[ind] <- sprintf("[%4.2f,", as.numeric(tbl[ind]))
ind <- cbind(c(2,4,6), c(3,3,3,5,5,5))
tbl[ind] <- sprintf("%4.2f]", as.numeric(tbl[ind]))
ind <- cbind(c(1,3,5), c(2,2,2,4,4,4))
tbl[ind] <- sprintf("%4.2f", as.numeric(tbl[ind]))
ind <- cbind(c(1,3,5), c(3,3,3,5,5,5))
tbl[ind] <- ""
print(tbl)

if (to.latex) {
    filename <- "tables/returns_cycles.tex"
    sink(filename)
    print(xtable(tbl, digi=2),
          include.rownames=FALSE, include.colnames=FALSE, only.contents=TRUE,
          sanitize.text.function=function(x){x}, hline.after=nrow(tbl)-1)
    sink()
}
