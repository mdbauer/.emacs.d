## simulate data and IM test in simplest possible setting
## to understand power of IM

rm(list=ls())
set.seed(616)
library(xtable)
source("R/robust_fns.r")  ## for getMueller and asymTstat

M <- 1000
qs <- c(2,4,8,16,24)
T <- 128
rho <- 0.9

doWork <- function(beta1=0, beta2=0) {
    ## Globals: T, M, qs, delta, rho
    b <- matrix(NA, M, 2)
    se <- matrix(NA, M, 2)
    pvalsIM <- matrix(NA, M, length(qs))
    n <- T
    for (i in 1:M) {
        if (i%%500==0)
            cat("Iteration", i, "\n")
        eps <- matrix(rnorm(n*3), n, 3)
        x1 <- numeric(n)
        x2 <- numeric(n)
        u <- numeric(n)
        x1[1] <- rnorm(1, sd=1/sqrt(1-rho^2))
        x2[1] <- rnorm(1, sd=1/sqrt(1-rho^2))
        u[1] <- rnorm(1, sd=1/sqrt(1-rho^2))
        for (t in 2:n) {
            x1[t] <- rho*x1[t-1] + eps[t, 1]
            x2[t] <- rho*x2[t-1] + eps[t, 2]
            ## u[t] <- rho*u[t-1] + eps[t, 3]
        }
        u <- 1/sqrt(1-rho^2)*eps[,3]
        y <- beta1*x1 + beta2*x2 + u
        df <- data.frame(y = y, x1 = x1, x2 = x2)
        ## estimate model in simulated data
        mod12 <- lm(y ~ x1 + x2, data=df)
        b[i, ] <- mod12$coef[-1]
        se[i, ] <- sqrt(diag(vcov(mod12)))[-1]
        ## IM
        for (q in qs) {
            rval <- getMueller(y ~ x1 + x2, data = df, q=q)
            pvalsIM[i, which(qs==q)] <- rval$tpval[2]
        }
    }
    t <- b/se
    cv <- qt(0.975, n-3)
    c(colMeans(b), mean(abs(t[,2])>cv), colMeans(pvalsIM<0.05))
}

cat("# Simulating...\n")
nms <- c("beta1", "beta2", "mean(b1)", "mean(b2)", "size OLS", paste("size IM", qs))
tbl <- matrix(NA, length(nms), 2)
rownames(tbl) <- nms
tbl[, 1] <- c(0, 0, doWork())
beta1 <- 0
beta2 <- 1
tbl[, 2] <- c(beta1, beta2, doWork(beta1=beta1, beta2=beta2))
print(round(tbl, digi=3))

