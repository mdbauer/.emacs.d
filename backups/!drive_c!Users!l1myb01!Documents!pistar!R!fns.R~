getCoreCPIq <- function() {
    ## quarterly Core CPI
    df <- read.csv("data/macro_v2.csv", na.string="#N/A")
    df$Date <- as.Date(as.character(10000*df$Year + 300*df$Quarter - 200 + 1), "%Y%m%d")
    df$pi <- 4*df$corecpi
    subset(df, Date > "1960-01-01")
}

getGDPDef <- function() {
    ## quarterly GDP inflation
    df <- read.csv("data/gdpdef.csv")
    df$Date <- as.Date(df$date)
    df$pi <- c(NA, 400*diff(log(df$GDPDEF)))
    ## Stock-Watson sub-samples
    ##df <- subset(df, date >= "1960-01-01" & date<="1983-12-30") ## their first subsample
    ##df <- subset(df, date >= "1984-01-01" & date<="2004-12-30") ## their second subsample
    subset(df, Date > "1960-01-01")
}

getCoreCPIm <- function(change = c("yoy", "qoq", "mom"), sa = TRUE) {
    ## Monthly Core CPI (as in Cieslak-Povala)
    change <- match.arg(change)
    if (sa) {
        ## seasonally adjusted
        cpi <- read.csv("data/corecpi_monthly_sa.csv")
        cpi$Date <- as.Date(cpi$Date)
    } else {
        ## NSA
        cpi <- read.csv("data/corecpi_monthly.csv")
        cpi$Date <- as.Date(cpi$Date, format = "%m/%d/%Y")
    }
    T <- nrow(cpi)
    if (change == "mom") {
        ## month-over-month
        cpi$pi <- 1200*c(NA, log(cpi$CPI[2:T]) - log(cpi$CPI[1:(T-1)]))
    } else if (change == "yoy") {
        ## year-over-year
        cpi$pi <- 100*c(rep(NA, 12), log(cpi$CPI[13:T]) - log(cpi$CPI[1:(T-12)]))
    } else if (change == "qoq") {
        ## quarter-over-quarter
        cpi$pi <- 400*c(rep(NA, 3), log(cpi$CPI[4:T]) - log(cpi$CPI[1:(T-3)]))
    }
    subset(cpi, Date > "1970-01-01")
}

getEWMA <- function(x, v = 0.987, y0) {
    ## calculate exponentially-weighted moving average as in Cieslak-Povala
    tau <- numeric(length(x))
    if (missing(y0)) {
        tau[1] <- x[1]
    } else {
        tau[1] <- y0
    }
    for (t in 2:length(x))
	tau[t] <- tau[t-1] + (1-v)*(x[t] - tau[t-1])
    tau
}

var.ratio <- function(pi, maxlag = 12) {
    ## adapted from vrtest:::stat.plot (used in vrtest::VR.plot, for example)
    y <- diff(pi)
    vr <- numeric(maxlag)
    for (k in 1:maxlag) {
        y <- as.matrix(y)
        n <- nrow(y)
        m <- mean(y)
        vr1 <- sum((y - m)^2)/n
        flt = filter(y, rep(1, k), method = "convolution") # sum of k observations
        flt = flt[!is.na(flt)]
        summ = sum((flt - k * m)^2)
        vr2 <- summ/(n * k)
        vr[k] <- vr2/vr1
    }
    vr
}

getPiStats <- function(data) {
    ## statistics about inflation
    data$pistar <- getEWMA(data$pi)  ## estimate pi-star
    gap <- data$pi - data$pistar
    res1 <- setNames(c(var(data$pi), acf(data$pi, plot=FALSE)$acf[2],
               var(diff(data$pi)),
               var(data$pistar), acf(data$pistar, plot=FALSE)$acf[2],
               var(diff(data$pistar)), acf(diff(data$pistar), plot=FALSE)$acf[2],
               var(gap),  acf(gap, plot=FALSE)$acf[2]),
             c("var(pi)", "acf(pi)", "var(d.pi)",
               "var(pistar)", "acf(pistar)", "var(d.pistar)", "acf(d.pistar)",
               "var(gap)", "acf(gap)"))
    ## ACF
    res2 <- setNames(acf(diff(data$pi), plot=FALSE)$acf[2:13], paste("rho(d.pi)", 1:12))
    ## Cochrane variance ratio - how big is the random walk component?
    res3 <- setNames(var.ratio(data$pi, 60), paste("vr", 1:60))
    c(res1, res2, res3[seq(6,60,6)])
}

printTblStats <- function(statsData, statsSim, statsPop=NA, digits=2) {
    tblStats <- cbind(statsData, t(apply(statsSim, 2, function(x) c(quantile(x, c(0.025, 0.5)), mean(x), quantile(x, 0.975)))))
    colnames(tblStats) <- c("Data", "LB", "Median", "Mean", "UB")
    rownames(tblStats) <- names(statsData)
    tblStats <- cbind(tblStats, (tblStats[,1] > tblStats[,2]) * (tblStats[,1] < tblStats[,5]))
    tblStats <- cbind(tblStats, tblStats[,3]/tblStats[,1], statsPop)
    colnames(tblStats)[c(6,7,8)] <- c("in CI?", "med/data", "pop.")
    print(round(tblStats, digits))
}

mytsdiag <- function(resid, gof.lag=10L) {
    ## basically tsdiag.StructTS
    dev.new()
    oldpar <- par(mfrow = c(3, 1))
    on.exit(par(oldpar))
    plot(resid/sd(resid), type = "h", main = "Standardized Residuals",
         ylab = "")
    abline(h = 0)
    acf(resid, plot = TRUE, main = "ACF of Residuals",
        na.action = na.pass)
    nlag <- gof.lag
    pval <- numeric(nlag)
    for (i in 1L:nlag) pval[i] <- Box.test(resid, i, type = "Ljung-Box")$p.value
    plot(1L:nlag, pval, xlab = "lag", ylab = "p value", ylim = c(0,
                                                        1), main = "p values for Ljung-Box statistic")
    abline(h = 0.05, lty = 2L, col = "blue")
}

uCovVar <- function(phi, omega) {
    ## unconditional covariance matrix of VAR(1)
    ## - can also be used to find unconditional variance of AR(p) process by using companion form
    N <- nrow(omega)
    matrix(solve(diag(N^2) - kronecker(phi, phi)) %*% as.numeric(omega), N, N)
}
