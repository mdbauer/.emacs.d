rm(list=ls())
require(sandwich) # NeweyWest()
require(xtable) # xtable()
source("R/trends_fns.r")

df <- loadData()
rownames(df) <- NULL
cat("Date range:", range(df$yyyymm), "\n")
T <- nrow(df)

## yields and PCs
N <- 10 # goal maturity for YTP
## -> need returns for bonds with maturity of 2 to N periods
## -> maturity of longest predictor yield is N-1
yield.cols <- attr(df, "yield.cols")[3:(2+N)]
mats <- (1:N)
Y <- data.matrix(df[,yield.cols])
Ypred <- data.matrix(df[,yield.cols[1:(N-1)]])
W <- eigen(cov(Ypred))$vectors[,1:3]
P <- Ypred %*% W
df[paste0("PC", 1:3)] <- P
tau <- as.matrix(df[c("pistar.ptr", "rstar.mean")])

## calculate excess returns
for (n in 2:N)
    df[paste0("xr", n)] <- c(-(n-1)*Y[5:T, mats == n-1] + n*Y[1:(T-4), mats == n] - Y[1:(T-4), mats == 1], rep(NA, 4))

B <- matrix(NA, N, 6)
for (n in 2:N) {
    depvar <- paste0("xr", n)
    fmla <- get(depvar) ~ PC1 + PC2 + PC3 + pistar.ptr + rstar.mean
    mod <- lm(fmla, df)
    print(summary(mod))
    B[n,] <- mod$coef
}

Erx_path <- matrix(NA, T, N-1)  # path of expected returns relevant for 10-year yield term premium

## iterate forward to get path of expected returns
Ey <- matrix(NA, T, N-1)
for (i in 1:(N-1)) { # for each forcast horizon
    X <- cbind(1, P, tau)  # expect P to contain E_t P_{t+1-i}
    Erx <- X %*% t(B)   # T x N -- i-step ahead expected excess returns for each maturity (first col empty)
    Erx_path[, i] <- Erx[, N-i+1]  # E_t rx_{t+i}^(n-i+1)
    ## construct expected yields from expected excess returns
    for (j in 1:(N-1)) # for each yield maturity
        Ey[,j] <-
## not sure how to continue-- could use approximation!
