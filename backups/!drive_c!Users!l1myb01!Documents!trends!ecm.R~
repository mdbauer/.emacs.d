## estimate error correction model
## for given cointegration vector
## using least squares

rm(list=ls())
library(dynlm)
library(sandwich) # vcovHC()
library(xtable) # xtable()
source("R/trends_fns.R")
df <- loadData()

p <- 4 # number of lags

## yieldvar <- "f510"
## getStats <- function(mod) {
##     b <- mod$coef
##     ## V <- vcov(mod) # OLS SEs
##     V <- vcovHC(mod) # robust SEs
##     tstats <- b/sqrt(diag(V))
##     pvals <- 2*pt(abs(tstats), df=mod$df.residual, lower.tail=FALSE)
##     cbind(b, pvals)
## }

## use only istar
## df$x <- df$istar
## df$y <- df[[yieldvar]]
## df$dy <- c(NA, diff(df$y))
## df$dx <- c(NA, diff(df$x))
## df$e <- df$y - df$x # cointegration residual
## ## df$e <- df$e - mean(df$e) # demean!
## nms <- c("const", "alpha", paste("gamma_x", 1:p), paste("gamma_y", 1:p))
## ##nms <- c("alpha", paste("gamma_x", 1:p), paste("gamma_y", 1:p))
## tbl <- matrix(NA, length(nms), 4)
## rownames(tbl) <- nms
## colnames(tbl) <- c("Eq (1) coeff", "Eq (1) pval", "Eq (2) coeff", "Eq (2) pval")
## mod <- dynlm(dy ~ L(e, 1)   + L(dy, 1:p) + L(dx, 1:p), data=ts(df))
## tbl[,1:2] <- getStats(mod)
## mod <- dynlm(dx ~ L(e, 1)  + L(dy, 1:p) + L(dx, 1:p), data=ts(df))
## tbl[,3:4] <- getStats(mod)
## print(summary(mod))
## print(round(tbl, 4))

## both trends -- three equations
## df$y1 <- df[[yieldvar]]
## df$y2 <- df$pistar.ptr
## df$y3 <- df$rstar.mean
## df$dy1 <- c(NA, diff(df$y1))
## df$dy2 <- c(NA, diff(df$y2))
## df$dy3 <- c(NA, diff(df$y3))
## df$e <- df$y1 - df$y2 - df$y3 # cointegration residual
## ## df$e <- df$e - mean(df$e) # demean!
## nms <- c("const", "alpha", paste("gamma_y1", 1:p), paste("gamma_y2", 1:p), paste("gamma_y3", 1:p))
## tbl <- matrix(NA, length(nms), 6)
## rownames(tbl) <- nms
## colnames(tbl) <- c("Eq (1) coeff", "Eq (1) pval", "Eq (2) coeff", "Eq (2) pval", "Eq (3) coeff", "Eq (3) pval")
## mod <- dynlm(dy1 ~ L(e, 1)   + L(dy1, 1:p) + L(dy2, 1:p) + L(dy3, 1:p), data=ts(df))
## tbl[,1:2] <- getStats(mod)
## mod <- dynlm(dy2 ~ L(e, 1)   + L(dy1, 1:p) + L(dy2, 1:p) + L(dy3, 1:p), data=ts(df))
## tbl[,3:4] <- getStats(mod)
## mod <- dynlm(dy3 ~ L(e, 1)   + L(dy1, 1:p) + L(dy2, 1:p) + L(dy3, 1:p), data=ts(df))
## tbl[,5:6] <- getStats(mod)
## print(summary(mod))
## print(round(tbl, 3))

##################################################
## both trends, one equation, all three yield vars
yieldvars <- c("y5", "y10", "f510")
tbl <- data.frame(matrix(NA, 4, 4))
colnames(tbl) <- c("", yieldvars)
tbl[,1] <- c("$\\hat{\\alpha}$", "", "$H_0: \\alpha=0$", "$H_0:$ not Granger causal")
for (i in seq_along(yieldvars)) {
    df$y1 <- df[[yieldvars[i]]]
    df$y2 <- df$pistar.ptr
    df$y3 <- df$rstar.mean
    df$dy1 <- c(NA, diff(df$y1))
    df$dy2 <- c(NA, diff(df$y2))
    df$dy3 <- c(NA, diff(df$y3))
    df$e <- df$y1 - df$y2 - df$y3 # cointegration residual
    mod <- dynlm(dy1 ~ L(e, 1) + L(dy1, 1:p) + L(dy2, 1:p) + L(dy3, 1:p), data=ts(df))
    b <- mod$coef
    V <- vcovHC(mod, "HC0") # robust SEs
    SEs <- sqrt(diag(V))
    tstats <- b/SEs
    pvals <- 2*pt(abs(tstats), df=mod$df.residual, lower.tail=FALSE)
    R <- rbind(c(0,1,rep(0, 3*p)),
               cbind(matrix(0, 2*p, p+2), diag(2*p)))
    F <- t(R %*% b) %*% solve(R %*% V %*% t(R)) %*% (R %*% b)/(2*p+1)
    pvalCausal <- pf(F, 2*p+1, mod$df.residual, lower.tail=FALSE)
    tbl[, 1+i] <- c(b[2], SEs[2], pvals[2], pvalCausal)
}
tbl[,-1] <- formatTbl(tbl[,-1], 2, fmt="%4.3f")
print(tbl)

sink("tables/ecm.tex")
print(xtable(tbl, digits=3),
      include.rownames=FALSE, include.colnames=FALSE, only.contents=TRUE,
      sanitize.text.function=function(x){x}, hline.after=NULL)
sink()

## q <- 2*p+1
## Vols <- vcov(mod)
## (F1 <- t(R %*% b) %*% solve(R %*% Vols %*% t(R)) %*% (R %*% b)/(2*p+1))
## modR <- dynlm(dy1 ~ L(dy1, 1:p), data=ts(df))
## ssrR <- sum(modR$residuals^2)
## ssrUR <- sum(mod$residuals^2)
## (F2 <- (ssrR-ssrUR)/q/ssrUR*mod$df.residual)
