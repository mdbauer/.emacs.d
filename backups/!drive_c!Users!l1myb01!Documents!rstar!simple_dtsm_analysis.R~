## analyze ML estimation results for simple DTSM

rm(list=ls())
source("R/fns.R")
graphics.off()

rval <- load("results/est_results_2017-07-10.RData")

cat("## Analysis of results\n")
cat("## Model:", description, "\n")

stopifnot(isTRUE(all.equal(theta, pars2theta(pars))))
cat("likelihood at optimum:", -obj(theta), "\n")

## ## look at results
## cat("# Parameters in unconstrained space and standard errors:\n")
## require(numDeriv)
## H <- hessian(obj, theta)
## SEs <- rep(NA, length(theta))
## try(SEs <- sqrt(diag(solve(H))))
## tbl2 <- cbind(theta, SEs, grad(obj, theta), diag(H), eigen(H)$values)
## colnames(tbl2) <- c("theta", "SEs", "gradient", "diag(H)", "eigen(H)")
## print(round(tbl2, d=4))

## TODO figure out why gradient-based optimization doesn't work
## cat("## gradient-based optimization...\n")
## rval <- optim(theta, obj, method="BFGS", hessian=TRUE, control = list(trace=6, REPORT=1, maxit=5000))
## rval <- optim(theta, obj, method="L-BFGS-B", hessian=TRUE, control = list(trace=6, REPORT=1, maxit=5000))
## cat("# Improved to:", -rval$value, "\n")
## print(rval[-6])
## H <- rval$hessian
## cat("Hessian eigenvalues", round(eigen(H)$values, 4), "\n")
## ## theta <- rval$par
## ## checkKKT(theta, obj)

loads <- affineLoadings(pars$mu, pars$phi, pars$lam0, pars$lam1, pars$Omega, pars$delta0, pars$delta1)
print(pars)
print(round(loads$A, 2))
print(round(loads$B, 2))

## TODO estimates and standard errors

## eigenvalues/half-life under P- and Q-measures
cat("P-eigenvalues:", eigen(pars$phi)$values, "\n")
phiQ <- pars$phi - pars$lam1
cat("Q-eigenvalues:", eigen(phiQ)$values, "\n")

## factors
kf <- kalmanDTSM(pars) # smooth=TRUE)
X <- t(kf$att)
## X <- t(kf$atT)  # smoothed
df$rstar <- X[,3] #kf$att[3,]
## df$rstarSm <- kf$atT[3,]
df$pistar <- X[,1] #kf$att[1,]
## df$pistarSm <- kf$atT[1,]
df$istar <- df$pistar + df$rstar
## df$istarSm <- df$pistarSm + df$rstarSm
df$pihat <- rowSums(X[, 1:2])

## fitted yields / fit of measurement equations
Y <- df[yield.cols]
T <- nrow(Y)
Yhat <- rep(1, T) %*% loads$A + X %*% loads$B
cat("fit -- RMSE (bps)\n")
cat("inflation:", sqrt(mean((df$pi[2:T] - df$pihat[1:(T-1)])^2))*100, "\n")
cat("yields:", sqrt(mean((Y-Yhat)^2))*100, "\n")
cat("PTR:", sqrt(mean((df$ptr - X[, 1])^2, na.rm=TRUE))*100, "\n")
cat("SDs of meas. errors:", 100*sqrt(pars$sig2), "\n")

## risk-neutral yields
loadsRn <- affineLoadings(pars$mu, pars$phi, matrix(0, 5, 1), matrix(0, 5, 5), pars$Omega, pars$delta0, pars$delta1)
Yrn <- rep(1, T) %*% loadsRn$A + X %*% loadsRn$B
Ytp <- Yhat - Yrn

## plot r* - filtered and smoothed - vs. Laubach-Williams and others
cols <- c("black", "steelblue", "red", "green", "orange", "blue")
dev.new()
plot(df$Date, df$y10, type="l", col=cols[1], ylim=range(df$y10, 0, df$istar, df$rstar), ylab="", xlab="", main="Estimates of r*")
lines(df$Date, df$istar, col=cols[2], lwd=2)
lines(df$Date, df$rstar, col=cols[3], lwd=2)
df <- merge(df, loadLW(), all.x=TRUE)
ind <- !is.na(df$rstar.lw)
lines(df$Date[ind], df$rstar.lw.sm[ind], col=cols[4])
df <- merge(df, loadJM(), all.x=TRUE)
ind <- !is.na(df$rstar.jm)
lines(df$Date[ind], df$rstar.jm[ind], col=cols[5])
df <- merge(df, loadLM(), all.x=TRUE)
ind <- !is.na(df$rstar.lm)
lines(df$Date[ind], df$rstar.lm[ind], col=cols[6])
legend("topright", c("10-year yield", "DTSM i*", "DTSM r*",
                     "LW (smoothed)", "JM (filtered)", "LM (filtered)"), col=cols, lty=1, lwd=c(1,2,2,1,1,1))

## plot inflation, pi*, PTR, and fitted inflation
dev.new()
plot(df$Date, df$pi, type="l", col=cols[1], main="Inflation", ylab="", xlab="")
lines(df$Date, df$pihat, col=cols[2])
ind <- !is.na(df$ptr)
lines(df$Date[ind], df$ptr[ind], col=cols[3])
lines(df$Date, df$pistar, col=cols[4])
legend("topright", c("inflation", "fitted inflation", "PTR", "pi* (smoothed)"), col=cols, lty=1)

## 5-to-10-year forward rate, forward term premium, risk-neutral rate
dev.new()
df$f510 <- 2*df$y10 - df$y5
df$f510hat <- 2*Yhat[,mats==120] - Yhat[,mats==60]
df$f510rn <- 2*Yrn[,mats==120] - Yrn[,mats==60]
df$f510tp <- 2*Ytp[,mats==120] - Ytp[,mats==60]
plot(df$Date, df$f510, type="l", col=cols[1], ylim=range(df$f510, df$f510rn, df$f510tp), main="Decomposition of 5-to-10-year forward rate", ylab="", xlab="")
lines(df$Date, df$f510hat, col=cols[2])
lines(df$Date, df$f510rn, col=cols[3])
lines(df$Date, df$f510tp, col=cols[4])
legend("topright", c("actual", "fitted", "risk-neutral", "term premium"), col=cols, lty=1)

## expectations without convexity
loadsExp <- affineLoadings(pars$mu, pars$phi, matrix(0, 5, 1), matrix(0, 5, 5), matrix(0, 5, 5), 0, pars$delta1)
Yexp <- rep(1, T) %*% loadsExp$A + X %*% loadsExp$B
df$f510exp <- 2*Yexp[,mats==120] - Yexp[,mats==60]
## Q-expectations without convexity
loadsQexp <- affineLoadings(pars$mu, pars$phi, pars$lam0, pars$lam1, matrix(0, 5, 5), 0, pars$delta1)
YQexp <- rep(1, T) %*% loadsQexp$A + X %*% loadsQexp$B
df$f510Qexp <- 2*YQexp[,mats==120] - YQexp[,mats==60]
tmp <- df[c("f510", "f510hat", "f510rn", "f510tp", "f510exp", "istar", "f510Qexp")]
tmp <- cbind(tmp, df$f510hat - df$f510Qexp, df$f510rn - df$f510exp)
colnames(tmp)[8:9] <- c("Q conv", "P conv")
print(round(tail(tmp), 3))

## covariance of changes in i* and changes in forward rates
cor(diff(df$istar), diff(df$f510))
## other analysis:
## long-run expectation of nominal short rate under Q vs P
## long-run expectation of real short rate under Q vs P
## contributions of factors to yields
## LPY(i), LPY(ii), CP regressions


