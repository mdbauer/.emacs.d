## Table 3: predictive regressions
rm(list=ls())
require(sandwich) # NeweyWest()
require(xtable) # xtable()
source("R/trends_fns.r")
source("R/bootstrap_fns.r")

to.latex <- TRUE
vcovNW <- function(mod) NeweyWest(mod, lag=6, prewhite=FALSE)
varnames <- c("pistar.ptr", "rstar.mean")
specs <- rbind(c(1,0),
               c(1,1))
mats <- c(0.25, 0.5, 1:15)

for (subsample in c(FALSE, TRUE)) {

    df <- loadData()
    if (subsample)
        df <- df[df$yyyymm >= 198501, ]
    cat("Date range:", range(df$yyyymm), "\n")

    ## yields and PCs
    Y <- data.matrix(df[,attr(df, "yield.cols")])
    W <- eigen(cov(Y))$vectors[,1:3]
    W <- W %*% diag(sign(W[nrow(W),])) # make sure PC1 and PC2 correspond to level and slope
    df[paste0("PC", 1:3)] <- Y %*% W
    attr(df, 'mats') <- mats
    attr(df, 'W') <- W
    dgp <- getBootDGP(c("PC1", "PC2", "PC3"), varnames, df, BC=TRUE)
    T <- nrow(Y)
    tbl <- data.frame(matrix(NA, 11, 7))
    tbl[,1] <- sprintf("%-15s", c("PC1", "",
                                  "PC2", "",
                                  "PC3", "",
                                  "$\\pi_t^\\ast$", "",
                                  "$r_t^\\ast$", "",
                                  "$R^2$"))
    col <- 2
    for (h in c(1, 4)) {
        ## calculate excess returns
        df$xr.avg <- 0
        for (n in 2:15) {
            nmh <- ifelse(h==1, n, n-1) # approximate n-h - yield if quarterly change
            xrn <- c(-(n-h/4)*Y[(1+h):T, mats==nmh] + n*Y[1:(T-h), mats==n] - h/4*Y[1:(T-h), mats==h/4], rep(NA, h))
            df$xr.avg <- df$xr.avg + xrn/14
        }
        if (h==1) {
            df$xr.q <- df$xr.avg
            vcovfn <- function(mod) vcovHC(mod, "HC")
        } else if (h==4) {
            df$xr.a <- df$xr.avg
            vcovfn <- vcovNW
        }
        for (i in 0:2) {
            if (i==0) {
                fmla <- xr.avg ~ PC1 + PC2 + PC3
                regrows <- c(1,3,5)
            } else {
                regnames <- varnames[specs[i,]==1]
                fmla <- formula(paste("xr.avg ~ PC1 + PC2 + PC3 +", paste(regnames, collapse="+")))
                regrows <- c(1,3,5, seq(7, by=2, len=ncol(specs))[specs[i,]==1])
            }
            mod <- lm(fmla, df)
            tbl[regrows, col] <- mod$coef[-1]
            V <- vcovfn(mod)
            tbl[regrows+1, col] <- sqrt(diag(V))[-1]
            tbl[nrow(tbl), col] <- summary(mod)$r.squared
            col <- col+1
        }
    }
    tbl[,-1] <- formatTbl(tbl[,-1], se.rows=c(2,4,6,8,10))

    ## bootstrap p-values
    tbl <- rbind(tbl[1:8,], "", tbl[9:10,], "", tbl[11,])
    for (h in c(1, 4)) {
        if (h==1) {
            vcovfn <- function(mod) vcovHC(mod, "HC")
            fmla1 <- xr.q ~ PC1 + PC2 + PC3
            fmla2a <- xr.q ~ PC1 + PC2 + PC3 + pistar.ptr
            fmla2b <- xr.q ~ PC1 + PC2 + PC3 + pistar.ptr + rstar.mean
        } else if (h==4) {
            vcovfn <- vcovNW
            fmla1 <- xr.a ~ PC1 + PC2 + PC3
            fmla2a <- xr.a ~ PC1 + PC2 + PC3 + pistar.ptr
            fmla2b <- xr.a ~ PC1 + PC2 + PC3 + pistar.ptr + rstar.mean
        }
        ## pi-star only
        rval <- bootstrapTest(fmla1, fmla2a, df, dgp, h=h, vcovfn=vcovfn, M=5000)
        tbl[9, 2+h] <- sprintf("[%4.2f]", rval$tblCoef[5, 4])
        ##print(round(rval$tblCoef, 2))
        ##print(round(rval$tblR2, 3))
        ## pi-star and r-star
        rval <- bootstrapTest(fmla1, fmla2b, df, dgp, h=h, vcovfn=vcovfn, M=5000)
        tbl[c(9, 12), 3+h] <- sprintf("[%4.2f]", as.numeric(rval$tblCoef[5, 4:5]))
        ##print(round(rval$tblCoef, 2))
        ##print(round(rval$tblR2, 3))
    }

    print(tbl)

    if (to.latex) {
        filename <- ifelse(subsample, "tables/returns_subsample.tex", "tables/returns.tex")
        sink(filename)
        print(xtable(tbl, digi=2),
              include.rownames=FALSE, include.colnames=FALSE, only.contents=TRUE,
              sanitize.text.function=function(x){x}, hline.after=nrow(tbl)-1)
        sink()
    }
}
