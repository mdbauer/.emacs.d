## error correction model
rm(list=ls())
library(dynlm)
library(sandwich) # vcovHC()
library(xtable) # xtable()
source("R/trends_fns.R")
df <- loadData()

yieldvar <- "f510"
p <- 3 # number of lags

df$istar <- df$pistar.ptr + df$rstar.mean
df$x <- df$istar
df$y <- df[[yieldvar]]
df$dy <- c(NA, diff(df$y))
df$dx <- c(NA, diff(df$x))
df$e <- df$y - df$x # cointegration residual
df$e <- df$e - mean(df$e) # demean!

## nms <- c("const", "alpha", paste("gamma_x", 1:p), paste("gamma_y", 1:p))
nms <- c("alpha", paste("gamma_x", 1:p), paste("gamma_y", 1:p))
tbl <- matrix(NA, length(nms), 4)
rownames(tbl) <- nms
colnames(tbl) <- c("Eq (1) coeff", "Eq (1) pval", "Eq (2) coeff", "Eq (2) pval")

## mod <- dynlm(dy ~ L(e, 1), data=ts(df))
getStats <- function(mod) {
    b <- mod$coef
    ## V <- vcov(mod) # OLS SEs
    V <- vcovHC(mod) # robust SEs
    tstats <- b/sqrt(diag(V))
    pvals <- 2*pt(abs(tstats), df=mod$df.residual, lower.tail=FALSE)
    cbind(b, pvals)
}

mod <- dynlm(dy ~ L(e, 1) -1  + L(dy, 1:p) + L(dx, 1:p), data=ts(df))
tbl[,1:2] <- getStats(mod)
mod <- dynlm(dx ~ L(e, 1) -1 + L(dy, 1:p) + L(dx, 1:p), data=ts(df))
tbl[,3:4] <- getStats(mod)
print(summary(mod))
print(round(tbl, 4))

library(urca)
X <- df[, c(yieldvar, "istar")]

X <- df[, c(yieldvar, "pistar.ptr", "rstar.mean")]
vecmod <- ca.jo(X, ecdet = "const", type = "eigen", K=2, spec="transitory")
print(summary(vecmod))

vecmod <- ca.jo(X, ecdet = "none", type = "eigen", K=2, spec="transitory")
print(summary(vecmod))
rls <- cajorls(vecmod, r=1)
summary(rls$rlm)
rls$beta

## vecmod <- ca.jo(X, ecdet = "none", type = "trace", K=2, spec="transitory")
## print(summary(vecmod))

## source code: https://github.com/cran/urca/blob/master/R/ca-jo.R
## eigenvector (CI vectors) are in vecmod@V
## test statistics in vecmod@teststat
## critical values in vecmod@cval
## help(ca.jo)
## help(ca.jo-class)
## help(cajools)
## help(cajorls)

## read Kilian-Luetkepohl
## http://www-personal.umich.edu/~lkilian/SVARch03.pdf
