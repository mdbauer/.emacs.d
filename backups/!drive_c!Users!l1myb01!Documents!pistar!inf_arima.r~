## estimate UC model for inflation: RW + AR(1)
rm(list=ls())
graphics.off()
source("R/fns.R")     # getCoreCPIm()
source("R/uc_fns.R")  # kalman.arma()
library(forecast)  # for auto-arima, tsdisplay
set.seed(6)

df <- getCoreCPIm("yoy", sa=FALSE)
df$yyyymm <- as.numeric(format(df$Date, "%Y%m"))
df <- df[df$yyyymm>197300,]
## df <- getCoreCPIm("mom", sa=TRUE)
names(df)[2] <- "p"

## identification
## - ACF and PACF of change in y-o-y inflation
dev.new()
tsdisplay(diff(df$pi))
## - ACFs of log-prices, Delta lp, Delta_12 lp, Delta Delta_12 lp
dev.new()
lP <- log(ts(df$p))
par(mfrow=c(2,2))
acf(lP, 20, main="(a)")
acf(diff(lP), 20, main="(b)")
acf(diff(lP, 12), 20, main="(c)")
acf(diff(diff(lP, 12)), 20, main="(d)")

## cat("# automatic choice of ARIMA(p,1,q) model\n")
## (fit <- auto.arima(df$pi, d=1, D=0, max.p = 12, max.q = 12, max.P=0, max.Q=0, ic="aic", stepwise=FALSE))
## (fit <- auto.arima(df$pi, d=1, D=0, max.p = 12, max.q = 12, max.P=0, max.Q=0, ic="aicc", stepwise=FALSE))
## (fit <- auto.arima(df$pi, d=1, D=0, max.p = 12, max.q = 12, max.P=0, max.Q=0, ic="bic", stepwise=FALSE))
## print(fit)

## cat("# automatic choice of seasonal ARIMA(p,1,q)(P,1,Q)_s model\n")
## (fit <- auto.arima(df$p))
## (fit <- auto.arima(df$p, stepwise=FALSE, approximation=FALSE))
## (fit <- auto.arima(df$p, d=1, D=1, max.p=4, max.q=4, max.P=4, max.Q=4, stepwise=FALSE, approximation=FALSE))
## (fit <- auto.arima(df$p, lambda=0))

## ## unresstricted ARIMA
## order <- c(0,1,12)  # RW ends up much too large
## order <- c(12,1,1)  # doesn't capture higher-order autocorrs., works moderately well in simulation
## order <- c(12,1,4)
## order <- c(12,1,12) # works like a charm! high likelihood, residuals WN, all moments matched very well
## order <- c(3,1,2)
## order <- c(4,1,12)  # high LLK, resids WN, but moments not matched
## order <- c(2,1,13)  ## RW much too variable
## order <- c(2,1,12)
## order <- c(5,1,0)
## order <- c(1,1,1)
## print(arima.fit <- arima(df$pi, order))

##################################################
### Seasonal models

## ## for log CPI
## ## airline model
print(arima.fit <- arima(lP, order = c(0,1,1), seasonal = list(order = c(0,1,1), period=12)))
## ## plus AR(2)
print(arima.fit <- arima(lP, order = c(2,1,1), seasonal = list(order = c(0,1,1), period=12)))

## for y-o-y inflation
## restricted ARIMA models
## - should be similar to airline model parameters
## - this is 1-12-13 model of Findley et al
## order <- c(0,1,13)
## fixed <- c(NA, rep(0, 10), NA, NA)
## print(arima.fit <- arima(df$pi, order, fixed=fixed))
## -> MA(13) term is unrestricted, vs. in airline model it's  0.4031*-0.6896
## => relatively smooth trend! though residuals not quite white noise

## add AR terms to 1-12-13 model
order <- c(2,1,13)
fixed <- c(rep(NA, order[1]), NA, rep(0, 10), NA, NA)
print(arima.fit <- arima(df$pi, order, fixed=fixed))

##################################################
## model diagnostics for estimated arima model
tsdiag(arima.fit, 20)

## Kalman filter
p <- order[1]; q <- order[3]
pars <- list(phi = arima.fit$model$phi,
             theta = arima.fit$model$theta[1:q],
             sig2 = arima.fit$sigma2)
kf <- kalman.arma(pars, diff(df$pi))
cat("log-likelihood arima.fit:", arima.fit$loglik, "\n")
cat("log-likelihood by hand:  ", kf$logLik, "\n")

ptr <- read.csv("data/pistar_PTR.csv")
ptr$date <- as.Date(paste0(ptr$Year, "/", 3*ptr$Quarter, "/1"))

ucsv <- read.csv("data/ucsv.csv")
names(ucsv) <- c("date", "filt", "sm")
ucsv$year <- floor(ucsv$date)
ucsv$month <- (ucsv$date-ucsv$year)*12+3
ucsv$date <- as.Date(paste0(ucsv$year, "/", ucsv$month, "/1"))

## Beveridge-Nelson decomposition using Morley's state-space approach
df$BN <- c(NA, as.numeric(df$pi[-1] + kf$H %*% kf$F %*% solve(diag(nrow(kf$F)) - kf$F) %*% kf$att))
cat("BN trend at last obs:", tail(df$BN, 1), "\n")
cat("long-run forecast:   ", tail(predict(arima.fit, n.ahead=100)$pred, 1), "\n")

## plot
pdf("figures/bn_trend.pdf", width=7, height=5, pointsize=12)
par(mar=c(3,3,1,1))
cols <- c("black", "steelblue", "red", "green")
plot(df$Date, df$pi, col=cols[1], type="l", lwd=1, xlab="", ylab="")
lines(df$Date, df$BN, col=cols[2], lwd=2)
lines(df$Date, getEWMA(df$pi), col=cols[3], lwd=2)
lines(ptr$date, ptr$pistar_PTR, col=cols[4], lwd=2)
## lines(ucsv$date, ucsv$filt, col=cols[5], lwd=2)
legend("topright", c("Inflation", "BN trend", "EWMA", "PTR"), col=cols, lwd=c(1,2,2,2,2))
dev.off()


## simulate data
M <- 1000
T <- nrow(df)
statsData <- getPiStats(df)
stats <- matrix(NA, M, length(statsData))
cat("# Simulating samples: T =", T, ", M =", M, "...\n")
for (i in 1:M) {
    if (i %% 200==0) cat("Replication ", i, "\n")
    if (order[3] == 0) {
        sim <- arima.sim(n=T, list(order = order,
                         ar = arima.fit$model$phi, sd = sqrt(arima.fit$sigma2)))
    } else  {
        sim <- arima.sim(n=T, list(order = order,
                         ar = arima.fit$model$phi, ma = arima.fit$model$theta[1:order[3]]), sd = sqrt(arima.fit$sigma2))
    }
    simData <- data.frame(t = 1:T, pi = sim[-1])
    stats[i,] <- getPiStats(simData)
}
printTblStats(statsData, stats)

##################################################

## cat("# Estimation of ARMA(p,q) model by hand...\n")
## gamma2pars <- function(gamma) {
##     ## reparameterization from Jones (1980)
##     p <- order[1]; q <- order[3]
##     if (length(gamma)!=p+q+1)
##         stop("parameter vector has the wrong length")
##     u <- gamma[1:p]
##     v <- gamma[(p+1):(p+q)]
##     pars <- list(sig2 = exp(gamma[p+q+1]))
##     a <- (1-exp(-u))/(1+exp(-u)) # PACFs constrained to (-1,1)
##     b <- (1-exp(-v))/(1+exp(-v))
##     pars$phi <- DL.fast(a)
##     pars$theta <- DL.fast(b)
##     pars
## }
## pars2gamma <- function(pars) {
##     a <- ARMAacf(ar=pars$phi, pacf=TRUE) ## PACFs implied by AR(p)
##     b <- ARMAacf(ar=pars$theta, pacf=TRUE) ## similar for MA parameters
##     u <- -log((1-a)/(1+a))
##     w <- -log((1-b)/(1+b))
##     c(u, w, log(pars$sig2))
## }
## obj <- function(gamma)
##     -kalman.arma(gamma2pars(gamma), diff(df$pi))$logLik
## p <- order[1]
## q <- order[3]
## ## random starting values
## n <- 500
## gamma <- numeric(p+q+1)
## best.llk <- -obj(gamma)
## for (i in 1:n) {
##     gamma0 <- rnorm(p+q+1, sd=.1)
##     gamma0[p+q+1] <- rnorm(1, mean=-3, sd=.5)
##     llk <- -obj(gamma0)
##     if (llk>best.llk) {
##         best.llk <- llk
##         gamma <- gamma0
##         cat("best LLK improved to", best.llk, "\n")
##     }
## }
## stopifnot(all.equal(gamma, pars2gamma(gamma2pars(gamma))))
## cat("# 1. Nelder-Mead optimization...\n")
## rval <- optim(gamma, obj, control=list(maxit=5000))
## print(rval)
## gamma <- rval$par
## cat("# 2. gradient-based method...\n")
## ## require(ucminf)
## ## rval <- ucminf(gamma, obj, control=list(maxeval=1000))
## ## print(rval[c("value", "convergence", "message", "info")])
## rval <- optim(gamma, obj, method="L-BFGS-B", hessian=TRUE)
## print(rval[-6])
## H <- rval$hessian
## cat("Hessian eigenvalues", round(eigen(H)$values, 4), "\n")
## gamma <- rval$par
## checkKKT(gamma, obj)
## cat("# log-lik at optimum:", -obj(gamma), "\n")
## pars <- gamma2pars(gamma)
## cat("# Parameters in unconstrained space and standard errors:\n")
## SEs <- sqrt(diag(solve(H)))
## tbl <- cbind(gamma, SEs)
## print(round(tbl, d=4))
## cat("Actual parameters and standard errors:\n")
## obj2 <- function(x) {
##     pars <- list(phi = x[1:p],
##                  theta = x[(1+p):(p+q)],
##                  sig2 = x[p+q+1])
##     -kalman.arma(pars, diff(df$pi))$logLik
## }
## x <- unlist(pars[c("phi", "theta", "sig2")])
## stopifnot(all.equal(obj2(x), obj(gamma)))
## H2 <- hessian(obj2, x)
## SEs <- sqrt(diag(solve(H2)))
## tbl <- cbind(c(x, -obj(gamma)), c(SEs, NA),
##               c(arima.fit$model$phi, arima.fit$model$theta[1:q], arima.fit$sigma2, arima.fit$loglik),
##               c(sqrt(diag(arima.fit$var.coef)), NA, NA))
## rownames(tbl) <- c(paste("AR", 1:p), paste("MA", 1:q), "sigma^2", "LLK")
## colnames(tbl) <- c("Estimates", "SEs", "arima.fit", "SEs")
## print(round(tbl, d=4))

## possible further improvements
## - speed up further
##   - calculation of P0 could be improved, taking into account special nature of equations
##     - could use fortran function nag_kalman_init
##       http://www.nag.com/numeric/FN/manual/pdf/c29/c29m02_tsa_kalman_fn03.pdf
##       http://www.nag.com/numeric/RunderWindows.asp
## - understand and apply CSS to obtain starting values (e.g. Hamilton p.132)
