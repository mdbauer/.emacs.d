// -------------------------------//
// Author: David Zarruk Valencia  //
// Date:   June, 2017             //
// -------------------------------//


#include <iostream>
#include <Rcpp.h>
#include <time.h>
using namespace std;
using namespace Rcpp;

//======================================
//         Grids
//======================================

// [[Rcpp::export]]
NumericVector gridx(int nx, double xmin, double xmax){
  
  NumericVector xgrid(nx);

  double size = nx;
  double xstep = (xmax - xmin) /(size - 1);
  double it = 0;
  
  for(int i = 0; i < nx; i++){
    xgrid[i] = xmin + it*xstep;
    it++;
  }
  return(xgrid);
}

// [[Rcpp::export]]
NumericVector gride(int ne, double ssigma_eps, double llambda_eps, double m){
  
  NumericVector egrid(ne);
  
  // This grid is made with Tauchen (1986)
  double size = ne;
  double ssigma_y = sqrt(pow(ssigma_eps, 2) / (1 - pow(llambda_eps, 2)));
  double estep = 2*ssigma_y*m / (size-1);
  double it = 0;
  
  for(int i = 0; i < ne; i++){
    egrid[i] = (-m*sqrt(pow(ssigma_eps, 2) / (1 - pow(llambda_eps, 2))) + it*estep);
    it++;
  }
  return(egrid);
}

double normCDF(double value){
  return 0.5 * erfc(-value * M_SQRT1_2);
}

// [[Rcpp::export]]
NumericVector eprob(int ne, double ssigma_eps, double llambda_eps, double m, NumericVector egrid){
  
  NumericVector P(ne*ne);
  
  // This grid is made with Tauchen (1986)
  // P is: first ne elements are transition from e_0 to e_i,
  //       second ne elementrs are from e_1 to e_i, ...
  double w = egrid[1] - egrid[0];
  
  for(int j = 0; j < ne; j++){
    for(int k = 0; k < ne; k++){
      if(k == 0){
        P[j*ne + k] = normCDF((egrid[k] - llambda_eps*egrid[j] + (w/2))/ssigma_eps);
      } else if(k == ne-1){
        P[j*ne + k] = 1 - normCDF((egrid[k] - llambda_eps*egrid[j] - (w/2))/ssigma_eps);
      } else{
        P[j*ne + k] = normCDF((egrid[k] - llambda_eps*egrid[j] + (w/2))/ssigma_eps) - normCDF((egrid[k] - llambda_eps*egrid[j] - (w/2))/ssigma_eps);
      }
    }
  }
  
  return(P);
}

//======================================
//         MAIN  MAIN  MAIN
//======================================

// [[Rcpp::export]]
vector<double> value(int nx, double xmin, double xmax, 
                     int ne, double ssigma_eps, double llambda_eps, double m, 
                     double ssigma, double eeta, double ppsi, double rrho, 
                     double llambda, double bbeta, int T, double r, double w){ 

  //--------------------------------//
  //         Grid creation          //
  //--------------------------------//
  
  NumericVector xgrid, egrid, P;
  
  xgrid = gridx(nx, xmin, xmax);
  egrid = gride(ne, ssigma_eps, llambda_eps, m);
  P     = eprob(ne, ssigma_eps, llambda_eps, m, egrid);

  // Exponential of the grid e
  for(int i=0; i<ne; i++){
    egrid[i] = exp(egrid[i]);
  }

  vector<double> V;
  V.resize(T*nx*ne);

  //--------------------------------//
  //    Life-cycle computation      //
  //--------------------------------//

  double expected;
  double utility;
  double cons;
  double VV = pow(-10.0,5.0);
  
  cout << " " << endl;
  cout << "Life cycle computation: " << endl;
  cout << " " << endl;

  clock_t t, t0;
  t0 = clock();
  
  for(int age=T-1; age>=0; age--){

    for(int ix = 0; ix<nx; ix++){
      for(int ie = 0; ie<ne; ie++){
	    VV = pow(-10, 5);
        for(int ixp = 0; ixp < nx; ixp++){

          expected = 0.0;
          if(age < T-1){
            for(int iep = 0; iep < ne; iep++){
              expected = expected + P[ie*ne + iep]*V[(age+1)*nx*ne + ixp*ne + iep];
            }
          }

          cons  = (1 + r)*xgrid[ix] + egrid[ie]*w - xgrid[ixp];

          utility = pow(cons, 1-ssigma) / (1-ssigma) + bbeta*expected;

          if(cons <= 0){
            utility = pow(-10.0, 5.0);
          }

          if(utility >= VV){
            VV = utility;
          }
        }

        V[age*nx*ne + ix*ne + ie] = VV;
      }
    }
    
    t = clock() - t0;
    cout << "Age: " << age << ". Time: " << ((float)t/CLOCKS_PER_SEC) << " seconds." << endl;
  }
  
  cout << " " << endl;
  t = clock() - t0;
  cout << "TOTAL ELAPSED TIME: " << ((float)t/CLOCKS_PER_SEC) << " seconds. " << endl;
  cout << " " << endl;
  
  return V;
}
